<html>
<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>C++学习笔记 | CisseAway&#39;s blog</title>

<link rel="shortcut icon" href="https://cisse-away.github.io//favicon.ico?v=1634867107576">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cisse-away.github.io//styles/main.css">
<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css"> -->

<style>
    hr {
        margin-top: 1rem;
        margin-bottom: 1rem;
        border: 0;
        border-top: 1px solid rgba(0, 0, 0, 0.1);
    }
</style>

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>

<!-- <script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script> -->
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->


    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <style>
    /* 导航栏样式 */
    .navbar {
        position: relative;
        display: -ms-flexbox;
        display: flex;
        -ms-flex-wrap: wrap;
        flex-wrap: wrap;
        -ms-flex-align: center;
        align-items: center;
        -ms-flex-pack: justify;
        justify-content: space-between;
        padding: 0.5rem 1rem;
    }

    .navbar-brand {
        display: inline-block;
        padding-top: 0.3125rem;
        padding-bottom: 0.3125rem;
        margin-right: 1rem;
        font-size: 1.25rem;
        line-height: inherit;
        white-space: nowrap;
    }

    .navbar-brand:hover,
    .navbar-brand:focus {
        text-decoration: none;
    }

    .navbar-nav {
        display: -ms-flexbox;
        display: flex;
        -ms-flex-direction: column;
        flex-direction: column;
        padding-left: 0;
        margin-bottom: 0;
        list-style: none;
    }

    .navbar-collapse {
        -ms-flex-preferred-size: 100%;
        flex-basis: 100%;
        -ms-flex-positive: 1;
        flex-grow: 1;
        -ms-flex-align: center;
        align-items: center;
    }

    .navbar-toggler {
        padding: 0.25rem 0.75rem;
        font-size: 1.25rem;
        line-height: 1;
        background-color: transparent;
        border: 1px solid transparent;
        border-radius: 0.25rem;
    }

    .navbar-toggler:hover,
    .navbar-toggler:focus {
        text-decoration: none;
    }

    @media (min-width: 992px) {
        .navbar-expand-lg {
            -ms-flex-flow: row nowrap;
            flex-flow: row nowrap;
            -ms-flex-pack: start;
            justify-content: flex-start;
        }

        .navbar-expand-lg .navbar-nav {
            -ms-flex-direction: row;
            flex-direction: row;
        }

        .navbar-expand-lg .navbar-collapse {
            display: -ms-flexbox !important;
            display: flex !important;
            -ms-flex-preferred-size: auto;
            flex-basis: auto;
        }

        .navbar-expand-lg .navbar-toggler {
            display: none;
        }
    }

    @media (max-width: 991px) {
        #navbarSupportedContent {
            display: none;
        }
    }
</style>
<nav class="navbar navbar-expand-lg">
    <div class="navbar-brand">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            CisseAway&#39;s blog
        </div>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
        aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
            <div class="nav-item">
                
                <a href="/" class="menu gt-a-link">
                    首页
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/archives" class="menu gt-a-link">
                    归档
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/tags" class="menu gt-a-link">
                    标签
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/post/about" class="menu gt-a-link">
                    关于
                </a>
                
            </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1634867107576"
                action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>
<script>
    /* 移动端导航栏展开/收起切换 */
    document.getElementById('changeNavbar').onclick = function () {
        var element = document.getElementById('navbarSupportedContent');
        if (element.style.display === 'none' || element.style.display === '') {
            element.style.display = 'block';
        } else {
            element.style.display = 'none';
        }
    }
</script>
    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    C++学习笔记
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2021-07-13 ·
                    </time>
                    
                        <a href="https://cisse-away.github.io/tag/rJGgUUKrk/" class="post-tags">
                            # C++
                        </a>
                    
                        <a href="https://cisse-away.github.io/tag/ikIb3j07A/" class="post-tags">
                            # 技术学习
                        </a>
                    
                </div>
                <div class="post-content">
                    <h1 id="课程链接">课程链接</h1>
<p><a href="https://www.xuetangx.com/learn/THU08091000247/THU08091000247/5884412">C++语言程序设计基础(2021春)</a><br>
<a href="https://www.xuetangx.com/learn/THU08091000248/THU08091000248/5884411/">C++语言程序设计进阶(2021春)</a></p>
<h1 id="第一章-绪论">第一章 绪论</h1>
<ol>
<li>
<h5 id="c支持的程序设计方法">C++支持的程序设计方法</h5>
<ul>
<li>面向过程的程序设计方法</li>
<li>面向对象的程序设计方法
<blockquote>
<p><strong>面向过程：</strong><br>
​    <strong>优点</strong>：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素<br>
​    <strong>缺点</strong>：没有面向对象易维护、易复用、易扩展<br>
<strong>面向对象：</strong><br>
​    <strong>优点</strong>：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护<br>
​    <strong>缺点</strong>：性能比面向过程低</p>
</blockquote>
</li>
<li>泛型程序设计方法（写的代码可以被很多不同类型的对象所重用，一般由继承实现）</li>
</ul>
</li>
<li>
<h5 id="c程序的开发过程">C++程序的开发过程</h5>
<ul>
<li>算法设计</li>
<li>源程序编辑</li>
<li>编译</li>
<li><strong>连接</strong>：连接目标程序以及库中的某些文件，生成可执行文件</li>
<li>运行调试</li>
</ul>
</li>
<li>
<h5 id="三种不同类型的翻译程序">三种不同类型的翻译程序</h5>
<ul>
<li>汇编程序：将汇编语言源程序翻译成目标程序</li>
<li>编译程序：将高级语言源程序翻译成目标程序</li>
<li><strong>解释程序</strong>：将高级语言源程序翻译成机器指令，边翻译边执行</li>
</ul>
</li>
</ol>
<h1 id="第二章-c简单程序设计">第二章 C++简单程序设计</h1>
<ol>
<li>各基本类型的取值范围<br>
<img src="https://cisse-away.github.io//post-images/1626139957046.png" alt="各基本类型的取值范围" loading="lazy"></li>
<li>
<h5 id="符号常量">符号常量</h5>
<ul>
<li>常量定义语句形式：<pre><code>const 数据类型 常量名 = 常量值
</code></pre>
</li>
<li>符号常量定义时一定要初始化，在程序中间不能改变其值</li>
</ul>
</li>
<li>
<h5 id="逗号运算和逗号表达式">逗号运算和逗号表达式</h5>
<ul>
<li>格式：表达式1，表达式2</li>
<li>求解顺序及结果：先求表达式1，再求表达式2，最终结果为表达式2的值</li>
</ul>
</li>
<li>
<h5 id="枚举类型">枚举类型</h5>
<ul>
<li>语法形式：<pre><code class="language-C++">enum &lt;枚举类型名&gt; {变量值列表}
// 例
enum Weekday{SUN, MON, TUE, WED, THU, FRI, SAT};
// 默认情况下：SUN=0,MON=1, ......, SAT=6
</code></pre>
<strong>注意</strong>：整数值不能直接赋给枚举变量，要进行强制类型转换，枚举值可以赋给整型变量</li>
<li>示例程序：<pre><code class="language-C++">#include &lt;iostream&gt;
using namespace std;
enum GameResult {WIN, LOSE, TIE, CANCEL};
int main() {
	GameResult result;
	enum GameResult omit = CANCEL;  
	for (int count = WIN; count &lt;= CANCEL; count++) {
		result = GameResult(count);
		if (result == omit)
			cout &lt;&lt; &quot;The game was cancelled&quot; &lt;&lt; endl;
		else {
			cout &lt;&lt; &quot;The game was played &quot;;
		    if (result == WIN) cout &lt;&lt; &quot;and we won!&quot;;
		    if (result == LOSE) cout &lt;&lt; &quot;and we lost.&quot;;
		    cout &lt;&lt; endl;
		}
	}
	return 0;
}
/* 输出：
The game was played and we won!
The game was played and we lost.
The game was played
The game was cancelled
*/
</code></pre>
</li>
</ul>
</li>
<li>
<h5 id="auto-类型与-decltype类型">auto 类型与 decltype类型</h5>
<ul>
<li><code>auto</code>：编译器通过初始值自动判断变量的类型</li>
<li><code>decltype</code>：定义一个变量与某一表达式的类型相同，但并不用该表达式初始换变量<pre><code class="language-C++">// sum的类型就是函数f返回值的类型
decltype(f()) sum = x;
</code></pre>
<ul>
<li>为了解决复杂的类型声明而使用的关键字</li>
<li>可以作用于变量、表达式及函数名</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="第三章-函数">第三章 函数</h1>
<ol>
<li>函数的参数传递
<ul>
<li>在函数调用时才分配形参的存储单元</li>
<li>值传递是单项传递，<strong>引用传递可实现双向传递</strong></li>
<li>常引用作参数可以保障实参数据的安全
<blockquote>
<p>一般引用作形参：</p>
<ol>
<li>不用作参数传递（实参赋值给形参），节省开销，提高效率。</li>
<li>函数可以改变形参的值</li>
<li>实参不能是常量<br>
常引用作形参：</li>
<li>不用作参数传递（实参赋值给形参），节省开销，提高效率。</li>
<li>函数不能改变形参的值</li>
<li>实参可以是常量</li>
</ol>
</blockquote>
</li>
</ul>
</li>
<li>引用的概念
<ul>
<li>定义一个引用时，必须同时对它进行初始化，使它指向一个已存在的对象</li>
<li>一旦一个引用被初始化后，就不能改为指向其他对象</li>
</ul>
</li>
<li>含有可变参数的函数
<ul>
<li><code>initializer_list</code><pre><code class="language-C++">initializer_list &lt;变量类型&gt; 变量名
</code></pre>
<ul>
<li><code>initializer_list</code>是一个类模板</li>
<li>其对象中的元素永远是常量值，无法改变元素的值</li>
</ul>
</li>
</ul>
</li>
<li>内联函数
<ul>
<li>在函数声明前加上关键字<code>incline</code></li>
<li>编译时在调用出用函数体进行替换，节省了参数传递，控制转移等开销</li>
<li>内联函数体内不能有循环语句和<code>switch</code>语句</li>
<li>内联函数的定义必须出现在内联函数第一次被调用之前</li>
<li>对内联函数不能进行异常接口声明</li>
</ul>
</li>
<li><code>constexpr</code>函数
<ul>
<li>语法规定：
<ul>
<li><code>constexpr</code>修饰的函数在其所有参数都是<code>constexpr</code>时，一定返回<code>constexpr</code>;</li>
<li>函数体中必须有且只有一条<code>return</code>语句</li>
</ul>
</li>
<li>示例：<pre><code class="language-C++">constexpr int get_size() {return 20;}
constexpr int foo = get_size();
</code></pre>
</li>
</ul>
</li>
<li>带默认参数值的函数
<ul>
<li>默认参数值的说明次序：<strong>有默认参数的形参必须列在形参列表的最右</strong></li>
<li>默认参数值与函数的调用位置：若一个函数有原型声明，且原型声明在定义之前，则默认参数值应在函数原型声明中给出；若只有函数的定义，或函数定义在前，则默认参数值可以函数定义中给出</li>
</ul>
</li>
<li>函数重载
<ul>
<li>功能相近的函数在相同的作用域内衣相同函数名声明</li>
<li>示例：<pre><code class="language-c++">// 形参类型不同
int add(int x, int y);
float add(float x, float y);
// 形参个数不同
int add(int x, int y);
int add(int x, int y, int z);
</code></pre>
</li>
</ul>
</li>
</ol>
<h1 id="第四章-类与对象">第四章 类与对象</h1>
<ol>
<li>如果紧跟在类名称的后面声明私有成员，则关键字<code>private</code>可以省略</li>
<li><code>private</code>类型与<code>protect</code>类型
<ul>
<li><code>private</code>修饰的成员变量只有类内可直接访问</li>
<li><strong><code>protect</code>修饰的成员变量类内和子类均可直接访问</strong></li>
</ul>
</li>
<li>默认构造函数
<ul>
<li>调用时可以不需要实参的构造函数
<ul>
<li>参数表为空的构造函数</li>
<li>全部参数都有默认值的构造函数</li>
</ul>
</li>
<li>示例：<pre><code class="language-C++">// 下面两个函数若在类中同时出现将产生编译错误
Clock();
Clock(int newH = 0, int newM = 0, int newS = 0);
</code></pre>
</li>
</ul>
</li>
<li>委托构造函数
<ul>
<li>类中往往有多个构造函数，只是参数表和初始化列表不同，其初始化算法都是相同的， 这时，为了避免代码重复，可以使用委托构造函数。</li>
<li>示例：<pre><code class="language-C++">// 构造函数
Clock(int newH, int newM, int newS): hour(newH), minute(newM), second(newS){ }
// 委托构造函数
Clock(): Clock(0, 0, 0) {}
</code></pre>
</li>
</ul>
</li>
<li>复制构造函数
<ul>
<li>其形参为本类的对象引用</li>
<li>作用：用一个已存在的对象去初始化同类型的新对象</li>
<li>示例：<pre><code class="language-C++">class 类名 {
public : 
   类名（形参）；//构造函数 
   类名（const 类名 &amp;对象名）；//复制构造函数
    // ...
}；
类名::类（ const 类名 &amp;对象名）//复制构造函数的实现
{ 函数体 }
</code></pre>
</li>
<li>复制构造函数被调用的情况
<ul>
<li>定义一个对象时，已本类另一个对象作为初始值，发生复制构造</li>
<li>若函数的形参是类的对象，调用函数时，将使用实参对象初始化形参对象，发生复制构造</li>
<li>如果函数的返回值是类的对象，函数执行完成返回主调函数时，将使用return语句中的对象初始化一个临时无名对象传递给主调函数，此时发生复制构造</li>
</ul>
</li>
</ul>
</li>
<li>前向引用声明
<ul>
<li>若需要在某个类的声明之前引用该类，则应进行前向引用声明</li>
<li>在提供一个完整的类声明之前，不能声明该类的对象，也不能在内联成员函数中使用该类的对象</li>
<li>当使用前向引用声明时，只能使用被声明的符号，而不能设计类的任何细节</li>
<li>示例：<pre><code class="language-C++">// 正确示例
class B; //前向引用声明
class A {
	public:
    	void f(B b);
};
class B {
 	public:
       void g(A a);
};
//-----------------------
// 错误示例
class Fred; //前向引用声明
class Barney {
 	Fred x; //错误：类Fred的声明尚不完善
};
class Fred {
  	Barney y;
};
// 应改为:
class Fred; //前向引用声明
class Barney {
    Fred *x; 
};
class Fred {
    Barney y;
}; 
</code></pre>
</li>
</ul>
</li>
<li>结构体与类
<ul>
<li>类的缺省访问权限时<code>private</code>，结构体的缺省访问权限是<code>public</code></li>
<li>结构体主要用来保存数据、没有什么操作的类型</li>
</ul>
</li>
<li>联合体
<ul>
<li>特点：
<ul>
<li>成员共用同一组内存单元</li>
<li>任何两个成员不会同时有效</li>
</ul>
</li>
<li>示例：<pre><code class="language-C++">union Mark { //表示成绩的联合体
    char grade; //等级制的成绩
    bool pass; //只记是否通过课程的成绩    
    int percent; //百分制的成绩
};
</code></pre>
</li>
</ul>
</li>
<li>枚举类
<ul>
<li>语法形式：<pre><code class="language-C++">enum class 枚举类型名: 底层类型 {枚举值列表};
</code></pre>
</li>
<li>示例：<pre><code class="language-c++">enum class Type { General, Light, Medium, Heavy};
enum class Type: char { General, Light, Medium, Heavy};
enum class Category { General=1, Pistol, MachineGun, Cannon};
</code></pre>
</li>
<li>常与<code>switch</code>, <code>case</code>一同使用</li>
</ul>
</li>
</ol>
<h1 id="第五章-数据的共享与保护">第五章 数据的共享与保护</h1>
<ol>
<li>对象的生存期
<ul>
<li>静态生存期
<ul>
<li>与程序的运行期相同</li>
<li>在文件作用域中声明的对象具有这种生存期</li>
<li>在函数内部声明静态生存期对象，要用关键字<code>static</code></li>
</ul>
</li>
<li>动态生存期
<ul>
<li>块作用域中声明的，没有用static修饰的对象是动态生存期的对象（习惯称局部生 存期对象）</li>
<li>开始于程序执行到声明点时，结束于命名该标识符的作用域结束处</li>
</ul>
</li>
</ul>
</li>
<li>类的静态数据成员
<ul>
<li>用关键字<code>static</code>声明</li>
<li><strong>为该类的所有对象共享</strong></li>
<li>必须在类外定义和初始化，用(::)来指明所属的类</li>
</ul>
</li>
<li>类的静态函数成员
<ul>
<li>类外代码可以使用类名和作用域操作符来调用静态成员函数</li>
<li>静态成员函数主要用于处理该类的静态数据成员，可以直接调用静态成员函数</li>
<li>如果访问非静态成员，要通过对象来访问</li>
</ul>
</li>
<li>类的友元
<ul>
<li>友元是C++提供的一种破坏数据封装和数据隐藏的机制</li>
<li>通过将一个模块声明为另一个模块的友元，一个模块能够引用到另一个模块中本是被隐藏的信息</li>
<li>可以使用友元函数和友元类</li>
</ul>
</li>
<li>友元函数
<ul>
<li>友元函数在它的函数体中能够通过对象名访问<code>private</code>和<code>protected</code>成员</li>
<li>作用：增加灵活性，使程序员可以在封装和快速性方面做合理选择</li>
<li>访问对象中的成员必须通过对象名</li>
<li>友元函数不是成员函数</li>
</ul>
</li>
<li>友元类
<ul>
<li>若一个类为另一个类的友元，则此类的所有成员都能访问对方类的私有成员</li>
<li><strong>类的友元关系是单向的</strong>，若声明B类是A类的友元，B类的成员函数就可以访问A类的私有和保护数据，但A类的成员函数却不能访问B类的私有、保护数据</li>
<li>示例：<pre><code class="language-C++">class A {
   friend class B;
   public:
       void display() {
           cout &lt;&lt; x &lt;&lt; endl;
       }
   private:
    	int x;
};
class B {
   public:
       void set(int i);
       void display();
   private:
    	A a;
};
void B::set(int i) {
    a.x=i;
}
void B::display() {
	 a.display();
}
</code></pre>
</li>
</ul>
</li>
<li>常类型
<ul>
<li>常对象：必须进行初始化,不能被更新<pre><code class="language-C++">const 类名 对象名
</code></pre>
</li>
<li>常成员：用<code>const</code>进行修饰的类成员：常数据成员和常函数成员
<ul>
<li>常成员函数不更新对象的数据成员</li>
<li>常成员函数声明格式：<pre><code class="language-C++">类型说明符 函数名（参数表）const;//在实现部分也要带const关键字
</code></pre>
</li>
<li>通过常对象只能调用它的常成员函数</li>
</ul>
</li>
<li>常引用：被引用的对象不能被更新<pre><code class="language-c++">const 类型说明符 &amp;引用名
</code></pre>
</li>
<li>常数组：数组元素不能被更新<pre><code class="language-c++">类型说明符 const 数组名[大小]
</code></pre>
</li>
<li>常指针：指向常量的指针</li>
</ul>
</li>
<li>C++程序的一般组织结构
<ul>
<li>类声明文件(.h文件)</li>
<li>类实现文件(.cpp文件)</li>
<li>类的使用文件(main()所在的.cpp文件)</li>
</ul>
</li>
<li>条件编译指令
<ul>
<li>
<pre><code class="language-C++">#if 常量表达式1
 程序正文1 //当“ 常量表达式1”非零时编译
#elif 常量表达式2
  程序正文2 //当“ 常量表达式2”非零时编译
#else 程序正文3 //其他情况下编译
#endif
</code></pre>
</li>
<li>
<pre><code class="language-C++">#ifdef 标识符
 程序段1
#else
 程序段2
#endif
// 如果“标识符”经#defined定义过，且未经undef删除，则编译程序段1；否则编译程序段2
</code></pre>
</li>
<li>
<pre><code class="language-C++">#ifndef 标识符
 程序段1
#else
 程序段2
#endif
// 如果“标识符”未被定义过，则编译程序段1；否则编译程序段2
</code></pre>
</li>
</ul>
</li>
</ol>
<h1 id="第六章-数组-指针与字符串">第六章 数组、指针与字符串</h1>
<ol>
<li>整数0可以赋给指针，表示空指针</li>
<li>允许定义或声明指向<code>void</code>类型的指针，该指针可以被赋予任何类型对象的地址</li>
<li>C++11使用<code>nullptr</code>关键字，是表达更准确，类型安全的空指针</li>
<li>指向常量的指针
<ul>
<li>不能通过指向常量的指针改变所指对象的值，但指针本身可以改变，可以指向其他的对象</li>
</ul>
</li>
<li>指针类型的常量
<ul>
<li>若声明指针常量，则指针本身的值不能被改变</li>
</ul>
</li>
<li>指针类型的函数
<ul>
<li>注意不要将非静态局部地址用作函数的返回值，例如：<pre><code class="language-C++">int* function(){
     int local=0; //非静态局部变量作用域和寿命都仅限于本函数体内
     return &amp;local;
}//函数运行结束时，变量local被释放 
</code></pre>
</li>
</ul>
</li>
<li>指向函数的指针
<ul>
<li>示例：<pre><code class="language-C++">#include &lt;iostream&gt;
using namespace std;

int compute(int a, int b, int(*func)(int, int))
{ return func(a, b);}

int max(int a, int b) // 求最大值
{ return ((a &gt; b) ? a: b);}

int min(int a, int b) // 求最小值
{ return ((a &lt; b) ? a: b);}

int sum(int a, int b) // 求和
{ return a + b;}

int main(){
     int a, b, res;
     cout &lt;&lt; &quot;请输入整数a：&quot;; cin &gt;&gt; a;     
     cout &lt;&lt; &quot;请输入整数b：&quot;; cin &gt;&gt; b; 

     res = compute(a, b, &amp; max);     
     cout &lt;&lt; &quot;Max of &quot; &lt;&lt; a &lt;&lt; &quot; and &quot; &lt;&lt; b &lt;&lt; &quot; is &quot; &lt;&lt; res &lt;&lt; endl；
     res = compute(a, b, &amp; min);     
     cout &lt;&lt; &quot;Min of &quot; &lt;&lt; a &lt;&lt; &quot; and &quot; &lt;&lt; b &lt;&lt; &quot; is &quot; &lt;&lt; res &lt;&lt; endl;
     res = compute(a, b, &amp; sum);     
     cout &lt;&lt; &quot;Sum of &quot; &lt;&lt; a &lt;&lt; &quot; and &quot; &lt;&lt; b &lt;&lt; &quot; is &quot; &lt;&lt; res &lt;&lt; endl;} 
</code></pre>
</li>
</ul>
</li>
<li>C++11 的智能指针
<ul>
<li><code>unique_ptr</code> ：不允许多个指针共享资源，可以用标准库中的<code>move</code>函数转移指针</li>
<li><code>shared_ptr</code> ：多个指针共享资源</li>
<li><code>weak_ptr</code> ：可复制<code>shared_ptr</code>，但其构造或者释放对资源不产生影响</li>
</ul>
</li>
<li>移动构造</li>
</ol>
<h1 id="第七章-继承与派生">第七章 继承与派生</h1>
<ol>
<li>单继承时派生类的定义<pre><code class="language-C++">class 派生类名：继承方式 基类名{ 	成员声明；} 
</code></pre>
</li>
<li>多继承时派生类的定义<pre><code class="language-C++">class 派生类名：继承方式1 基类名1，继承方式2 基类名2，...{
 	成员声明；
 }
 // 注意：每一个“继承方式”，只用于限制对紧随其后之基类的继承 
</code></pre>
</li>
<li>三种继承方式
<ul>
<li>公有继承
<ul>
<li>继承的访问控制
<ul>
<li>基类的<code>public</code>和<code>protected</code>成员：访问属性在派生类中保持不变</li>
<li>基类的<code>private</code>成员：不可直接访问</li>
</ul>
</li>
<li>访问权限
<ul>
<li>派生类中的成员函数：可以直接访问基类中的<code>public</code>和<code>protected</code>成员，但不能直接访问基类的private成员</li>
<li>通过派生类的对象：只能访问<code>public</code>成员</li>
</ul>
</li>
</ul>
</li>
<li>私有继承
<ul>
<li>继承的访问控制
<ul>
<li>基类的<code>public</code>和<code>protected</code>成员：都以<code>private</code>身份出现在派生类中</li>
<li>基类的<code>private</code>成员：不可直接访问</li>
</ul>
</li>
<li>访问权限
<ul>
<li>派生类中的成员函数：可以直接访问基类中的<code>public</code>和<code>protected</code>成员，但不能直接访问基类的<code>private</code>成员</li>
<li>通过派生类的对象：不能直接访问从基类继承的任何成员</li>
</ul>
</li>
</ul>
</li>
<li>保护继承
<ul>
<li>继承的访问控制
<ul>
<li>基类的<code>public</code>和<code>protected</code>成员：都以<code>protected</code>身份出现在派生类中</li>
<li>基类的<code>private</code>成员：不可直接访问</li>
</ul>
</li>
<li>访问权限
<ul>
<li>派生类中的成员函数：可以直接访问基类中的<code>public</code>和<code>protected</code>成员，但不能直接访问基类的<code>private</code>成员</li>
<li>通过派生类的对象：不能直接访问从基类继承的任何成员</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>protected</code>成员的特点与作用
<ul>
<li>对建立其所在类对象的模块来说，它与<code>private</code>成员的性质相同</li>
<li>对于其派生类来说，它与<code>public</code>成员的性质相同</li>
<li>既实现了数据隐藏，又方便继承，实现代码重用</li>
</ul>
</li>
<li>类型转换
<ul>
<li>公有派生类对象可以被当作基类的对象使用，反之则不可
<ul>
<li>派生类的对象可以隐含转换为基类对象</li>
<li>派生类的对象可以初始化基类的引用</li>
<li>派生类的指针可以隐含转换为基类的指针</li>
</ul>
</li>
<li><strong>通过基类对象名、指针只能使用从基类继承的成员</strong></li>
</ul>
</li>
<li>派生类的构造函数
<ul>
<li>单继承时构造函数的定义语法<pre><code class="language-C++">派生类名::派生类名(基类所需的形参，本类成员所需的形参):
基类名(参数表), 本类成员初始化列表{ 
   //其他初始化；
 }； 
</code></pre>
</li>
<li>多继承时构造函数的定义语法<pre><code class="language-C++">派生类名::派生类名(参数表) :
基类名1(基类1初始化参数表),
基类名2(基类2初始化参数表),
...
基类名n(基类n初始化参数表),
本类成员初始化列表 {
   //其他初始化；
 }； 
</code></pre>
</li>
</ul>
</li>
<li>构造函数的执行顺序
<ul>
<li>调用基类构造函数
<ul>
<li>顺序按照它们被继承时声明的顺序（从左向右）</li>
</ul>
</li>
<li>对初始化列表中的成员进行初始化
<ul>
<li>顺序按照它们在类中定义的顺序</li>
<li>对象成员初始化时自动调用其所属类的构造函数。由初始化列表提供参数</li>
</ul>
</li>
<li>执行派生类的构造函数体中的内容</li>
</ul>
</li>
<li>访问从基类继承的成员
<ul>
<li>作用域限定
<ul>
<li>当派生类与基类中有相同成员时：
<ul>
<li>若未特别限定，则通过派生类对象使用的是派生类中的同名成员</li>
<li>如要通过派生类对象访问基类中被隐藏的同名成员，应使用基类名和作用域操作符 （::）来限定</li>
</ul>
</li>
</ul>
</li>
<li>二义性问题
<ul>
<li>如果从不同基类继承了同名成员，但是在派生类中没有定义同名成员，“派生类对 象名或引用名.成员名”、“派生类指针-&gt;成员名”访问成员存在二义性问题</li>
<li>解决方式：用类名限定</li>
</ul>
</li>
</ul>
</li>
<li>虚基类
<ul>
<li>需要解决的问题
<ul>
<li>当派生类从多个基类派生，而这些基类又共同基类，则在访问此共同基类中 的成员时，将产生冗余，并有可能因冗余带来不一致性</li>
</ul>
</li>
<li>虚基类声明
<ul>
<li>以<code>virtual</code>说明基类继承方式</li>
<li>例：<pre><code class="language-C++">class B1:virtual public B 
</code></pre>
</li>
</ul>
</li>
<li>作用
<ul>
<li>主要用来解决多继承时可能发生的对同一基类继承多次而产生的二义性问题</li>
<li>为最远的派生类提供唯一的基类成员，而不重复产生多次复制</li>
</ul>
</li>
<li>注意：在第一级继承时就要将共同基类设计为虚基类</li>
<li>示例：<pre><code class="language-C++">#include &lt;iostream&gt;
using namespace std;
class Base0 {
	public: 
       int var0; 		
       void fun0() { cout &lt;&lt; &quot;Member of Base0&quot; &lt;&lt; endl; }
 };
 class Base1: virtual public Base0 {
 	public: 	
     	int var1;
 };
 class Base2: virtual public Base0 {
 	public: 	
     	int var2;
   };

 class Derived: public Base1, public Base2 {
 //定义派生类Derived	
 public:
     int var; 	
     void fun() { 	
         cout &lt;&lt; &quot;Member of Derived&quot; &lt;&lt; endl;
     }
 };
 int main() {
     Derived d;
     d.var0 = 2; //直接访问虚基类的数据成员
     d.fun0(); //直接访问虚基类的函数成员
     return 0;
 } 
</code></pre>
</li>
</ul>
</li>
</ol>
<h1 id="第八章-多态性">第八章 多态性</h1>
<ol>
<li>运算符重载为成员函数
<ul>
<li>重载为类成员的运算符函数定义形式<pre><code class="language-C++">函数类型 operator 运算符（形参）{ ......}// 参数个数=原操作数个数-1 （后置++、--除外） 
</code></pre>
</li>
<li>双目运算符重载规则
<ul>
<li>如果要重载 B 为类成员函数，使之能够实现表达式<code>oprd1 B oprd2</code>，其中<code>oprd1</code>为A 类对象，则 B 应被重载为 A 类的成员函数，形参类型应该是 <code>oprd2</code> 所属的类 型</li>
<li>经重载后，表达式<code>oprd1 B oprd2</code> 相当于 <code>oprd1.operator B(oprd2)</code></li>
</ul>
</li>
<li>前置单目运算符重载规则
<ul>
<li>如果要重载<code>U</code>为类成员函数，使之能够实现表达式 <code>U oprd</code>，其中 <code>oprd</code> 为A类对 象，则<code>U</code>应被重载为 A 类的成员函数，无形参</li>
<li>经重载后， 表达式<code>U oprd</code>相当于 <code>oprd.operator U()</code></li>
</ul>
</li>
<li>后置单目运算符 ++和--重载规则
<ul>
<li>如果要重载 <code>++</code>或<code>--</code>为类成员函数，使之能够实现表达式 <code>oprd++</code> 或<code>oprd--</code> ，其 中 <code>oprd</code> 为A类对象，则<code>++</code>或<code>--</code> 应被重载为 A 类的成员函数，且具有一个<code>int</code> 类 型形参</li>
<li>经重载后，表达式<code>oprd++</code> 相当于<code>oprd.operator ++(0)</code></li>
</ul>
</li>
<li>示例：(<strong>++i与i++区别原理</strong>)<pre><code class="language-C++">class Clock {//时钟类定义
	public: 
    	Clock(int hour = 0, int minute = 0, int second = 0); 
       void showTime() const; 	
   //前置单目运算符重载 		
       Clock&amp; operator ++ (); 		
   //后置单目运算符重载 		
       Clock operator ++ (int);
   private:
       int hour, minute, second;
};

Clock::Clock(int hour, int minute, int second) {
	 if (0 &lt;= hour &amp;&amp; hour &lt; 24 &amp;&amp; 0 &lt;= minute &amp;&amp; minute &lt; 60 &amp;&amp; 0 &lt;= second &amp;&amp; second &lt; 60) {
         this-&gt;hour = hour; 		
         this-&gt;minute = minute; 		
         this-&gt;second = second; 	
    } else 		
        cout &lt;&lt; &quot;Time error!&quot; &lt;&lt; endl;
}
void Clock::showTime() const { //显示时间 	
    cout &lt;&lt; hour &lt;&lt; &quot;:&quot; &lt;&lt; minute &lt;&lt; &quot;:&quot; &lt;&lt; second &lt;&lt; endl;
}

Clock &amp; Clock::operator ++ () {
	 second++;
    if (second &gt;= 60) {
    	 second -= 60; minute++;
        if (minute &gt;= 60) { 			
            minute -= 60; hour = (hour + 1) % 24; 		
        } 	
    }  
    return *this;
}

Clock Clock::operator ++ (int) { 
    //注意形参表中的整型参数
    Clock old = *this;
    ++(*this); //调用前置“++”运算符
    return old;
} 
</code></pre>
</li>
</ul>
</li>
<li>运算符重载为非成员函数
<ul>
<li>运算符重载为非成员函数的规则
<ul>
<li>双目运算符 B重载后，  表达式<code>oprd1 B oprd2</code> 等同于<code>operator B(oprd1, oprd2)</code></li>
<li>前置单目运算符 B重载后， 表达式<code>B oprd</code>等同于<code>operator B(oprd )</code></li>
<li>后置单目运算符<code>++</code>和<code>--</code>重载后， 表达式<code>oprd B</code> 等同于<code>operator B(oprd, 0)</code></li>
</ul>
</li>
<li>示例：<pre><code class="language-C++">class Complex {
	public: 	
    	Complex(double r = 0.0, double i = 0.0) : real(r), imag(i) { }
        friend Complex operator+(const Complex &amp;c1, const Complex &amp;c2)；
        friend Complex operator-(const Complex &amp;c1, const Complex &amp;c2)；
        friend ostream &amp; operator&lt;&lt;(ostream &amp;out, const Complex &amp;c)；
   private: 	
       double real; //复数实部 		
       double imag; //复数虚部
};
Complex operator+(const Complex &amp;c1, const Complex &amp;c2){ 
    return Complex(c1.real+c2.real, c1.imag+c2.imag);
}
Complex operator-(const Complex &amp;c1, const Complex &amp;c2){
 	return Complex(c1.real-c2.real, c1.imag-c2.imag);
}
ostream &amp; operator&lt;&lt;(ostream &amp;out, const Complex &amp;c){
  	  out &lt;&lt; &quot;(&quot; &lt;&lt; c.real &lt;&lt; &quot;, &quot; &lt;&lt; c.imag &lt;&lt; &quot;)&quot;; 	
     return out;
} 
</code></pre>
</li>
</ul>
</li>
<li>虚函数
<ul>
<li>虚函数时实现运行时多态性基础</li>
<li>构造函数不能时虚函数，析构函数可以是虚函数</li>
<li>虚函数的声明：<pre><code class="language-C++">virtual 函数类型 函数名（形参表）; 
</code></pre>
</li>
<li>虚函数声明只能出现在类定义中的函数原型声明中，而不能在成员函数实现的时候</li>
<li>在派生类中可以对基类中的成员函数进行覆盖</li>
<li><strong>派生类</strong>可以不显式地用<code>virtual</code>声明虚函数，系统判断条件为：
<ul>
<li>该函数是否与基类的虚函数有相同的名称、参数个数及对应参数类型</li>
<li>该函数是否与基类的虚函数有相同的返回值或者满足类型兼容规则的指针、 引用型的返回值</li>
</ul>
</li>
<li>若派生类从名称、参数及返回值三个方面满足上述条件就会自动确定为虚函数</li>
</ul>
</li>
<li>虚析构函数使用场景：
<ul>
<li>可能通过基类指针删除派生类对象</li>
<li>如果你打算允许其他人通过基类指针调用对象的析构函数（通过<code>delete</code>这样做是正 常的），就需要让基类的析构函数成为虚函数，否则执行<code>delete</code>的结果是不确定的</li>
</ul>
</li>
<li>虚表
<ul>
<li>每个多态类有一个虚表，其中有当前类的各个虚函数的入口地址</li>
<li>虚表示意图<br>
<img src="https://cisse-away.github.io//post-images/1626140181549.png" alt="虚表示意图" loading="lazy"></li>
</ul>
</li>
<li>抽象类
<ul>
<li>纯虚函数
<ul>
<li>纯虚函数是一个在基类中声明的虚函数，它在该基类中没有定义具体的操作内容， 要求各派生类根据实际需要定义自己的版本</li>
<li>纯虚函数的声明格式为：<pre><code class="language-C++">virtual 函数类型 函数名(参数表) = 0; 
</code></pre>
</li>
</ul>
</li>
<li>抽象类
<ul>
<li>带有纯虚函数的类称为抽象类:<pre><code class="language-C++">class  类名{     virtual 类型 函数名(参数表)=0;     //其他成员……}
</code></pre>
</li>
</ul>
</li>
<li><strong>注意</strong>：
<ul>
<li>抽象类只能作为基类来使用</li>
<li>不能定义抽象类的对象</li>
</ul>
</li>
</ul>
</li>
<li>C++11：<code>override</code>与<code>final</code>
<ul>
<li><code>override</code>
<ul>
<li>多态行为的基础：基类声明虚函数，继承类声明一个函数覆盖该虚函数</li>
<li>覆盖要求： 函数签名（函数名、参数列表、<code>const</code> ）完全一致</li>
</ul>
</li>
<li><code>final</code>
<ul>
<li>用来避免类被继承，或是基类的函数被改写</li>
<li>示例：<pre><code class="language-C++">struct Base1 final { };
struct Derived1 : Base1 { }; // 编译错误：Base1为final，不允许被继承 
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="第九章-模板与群体数据">第九章 模板与群体数据</h1>
<ol>
<li>函数模板定义语法
<ul>
<li>语法形式：<pre><code>template &lt;模板参数表&gt;函数定义
</code></pre>
</li>
<li>模板参数表的内容
<ul>
<li>类型参数：<code>class</code>（或<code>typename</code>）标识符</li>
<li>常量参数：类型说明符  标识符</li>
<li>模板参数：<code>template &lt;参数表&gt; class 标识符</code></li>
</ul>
</li>
</ul>
</li>
<li>类模板
<ul>
<li>类模板的声明：
<ul>
<li>类模板：<pre><code class="language-C++">template &lt;模板参数表&gt;class 类名 {类成员声明}; 
</code></pre>
</li>
<li>若需要在类模板以外定义其成员函数，则要采用以下的形式：<pre><code class="language-C++">template &lt;模板参数表&gt;类型名 类名&lt;模板参数标识符列表&gt;::函数名（参数表）
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="第十章-泛型程序设计与c标准模板库">第十章 泛型程序设计与C++标准模板库</h1>
<ol>
<li>泛型程序设计的基本概念
<ul>
<li>编写不依赖于具体数据类型的程序</li>
<li>将算法从特定的数据结构中抽象出来，成为通用的</li>
<li>C++的模板为泛型程序设计奠定了关键的基础</li>
</ul>
</li>
<li>STL的基本组件
<ul>
<li>容器(container)
<ul>
<li>基本容器类模板
<ul>
<li>顺序容器
<ul>
<li>array（数组）、vector（向量）、deque（双端队列）、forward_list（单链表）、list（列表）</li>
</ul>
</li>
<li>(有序)关联容器
<ul>
<li>set（集合）、multiset（多重集合）、map（映射）、multimap（多重映射）</li>
</ul>
</li>
<li>无序关联容器
<ul>
<li>unordered_set （无序集合）、unordered_multiset（无序多重集合）</li>
<li>unordered_map（无序映射）、unorder_multimap（无序多重映射）</li>
</ul>
</li>
</ul>
</li>
<li>容器适配器 ：stack（栈）、queue（队列）、priority_queue（优先队列）</li>
</ul>
</li>
<li>迭代器</li>
<li>函数对象</li>
<li>算法</li>
</ul>
</li>
</ol>
<h1 id="第十一章-流类库与输入输出">第十一章 流类库与输入/输出</h1>
<h1 id="第十二章-异常处理">第十二章 异常处理</h1>
<ol>
<li>异常处理的语法<br>
<img src="https://cisse-away.github.io//post-images/1626140220154.png" alt="异常处理的语法" loading="lazy">
<ul>
<li>示例：</li>
</ul>
<pre><code class="language-C++">#include &lt;iostream&gt;
using namespace std;
int divide(int x, int y) {
     if (y == 0)
          throw x;
     return x / y;
 }
 int main() {
     try {
         cout &lt;&lt; &quot;5 / 2 = &quot; &lt;&lt; divide(5, 2) &lt;&lt; endl;         
         cout &lt;&lt; &quot;8 / 0 = &quot; &lt;&lt; divide(8, 0) &lt;&lt; endl;        
         cout &lt;&lt; &quot;7 / 1 = &quot; &lt;&lt; divide(7, 1) &lt;&lt; endl;    
     } catch (int e) {
         cout &lt;&lt; e &lt;&lt; &quot; is divided by zero!&quot; &lt;&lt; endl; 
     }     
     cout &lt;&lt; &quot;That is ok.&quot; &lt;&lt; endl;     
     return 0;
 }
 // 输出
 5 / 2 = 28 is divided by zero!
 That is ok.
</code></pre>
</li>
<li>自动析构
<ul>
<li>找到到一个匹配的<code>catch</code>异常处理后
<ul>
<li>初始化异常参数</li>
<li>将从对应的<code>try</code>块开始到异常被抛掷处之间构造（且尚未析构）的所有自动 对象进行析构</li>
<li>从最后一个<code>catch</code>处理之后开始恢复执行</li>
</ul>
</li>
</ul>
</li>
<li>C++标准库各种异常类所代表的异常<img src="https://cisse-away.github.io//post-images/1626140283804.png" alt="各种异常类所代表的异常" loading="lazy"></li>
</ol>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://cisse-away.github.io/post/python-xue-xi-bi-ji/" class="post-title gt-a-link">
                    Python学习笔记
                </a>
            </div>
        

        

        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">Record Growth</div>
    <div class="social-container">
        
            
        
            
        
            
        
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
    <div>
        Theme by <a href="https://imhanjie.com/" target="_blank">imhanjie</a>, Powered by <a
                href="https://github.com/getgridea/gridea" target="_blank">Gridea | <a href="https://cisse-away.github.io//atom.xml" target="_blank">RSS</a></a>
    </div>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
</div>
</body>
</html>
